using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;
using Networking.Core;
using MinecraftProtocol;

namespace Minecraft.Core
{
    /// <summary>
    /// 마인크래프트 스타일 게임을 위한 네트워크 클라이언트
    /// 블록 관리, 청크 로딩, 플레이어 액션 등의 고급 기능을 제공합니다.
    /// </summary>
    public class MinecraftNetworkClient : MonoBehaviour
    {
        [Header(\"Connection Settings\")]
        [SerializeField] private string serverAddress = \"127.0.0.1\";
        [SerializeField] private int serverPort = 9000;
        [SerializeField] private float connectionTimeout = 10f;
        
        [Header(\"Game Settings\")]
        [SerializeField] private int renderDistance = 8; // 청크 렌더링 거리
        [SerializeField] private float tickRate = 20f;   // 게임 틱 레이트\n        \n        private INetworkTransport _transport;\n        private bool _isConnected = false;\n        private PlayerInfo _playerInfo;\n        private WorldInfo _worldInfo;\n        \n        // 청크 및 월드 데이터 관리\n        private Dictionary<Vector2Int, ChunkInfo> _loadedChunks = new();\n        private Dictionary<string, EntityInfo> _entities = new();\n        \n        // 네트워크 상태\n        private string _sessionToken;\n        private float _lastHeartbeat;\n        private Queue<IMessage> _outgoingMessages = new();\n        private Queue<IMessage> _incomingMessages = new();\n        \n        // 이벤트들\n        public event Action<bool> ConnectionStatusChanged;\n        public event Action<string> ErrorOccurred;\n        public event Action<PlayerInfo> PlayerInfoUpdated;\n        public event Action<ChunkInfo> ChunkLoaded;\n        public event Action<Vector3Int, int, int> BlockChanged;\n        public event Action<EntityInfo> EntitySpawned;\n        public event Action<string> EntityDespawned;\n        public event Action<ChatMessage> ChatMessageReceived;\n        \n        // 프로퍼티\n        public bool IsConnected => _isConnected;\n        public PlayerInfo PlayerInfo => _playerInfo;\n        public WorldInfo WorldInfo => _worldInfo;\n        public string SessionToken => _sessionToken;\n        public int LoadedChunkCount => _loadedChunks.Count;\n        \n        private void Awake()\n        {\n            InitializeClient();\n        }\n        \n        private void Update()\n        {\n            ProcessIncomingMessages();\n            ProcessOutgoingMessages();\n            \n            // 주기적 하트비트\n            if (_isConnected && Time.time - _lastHeartbeat > 1f / tickRate)\n            {\n                SendHeartbeat();\n                _lastHeartbeat = Time.time;\n            }\n        }\n        \n        private void InitializeClient()\n        {\n            _transport = new TcpNetworkTransport();\n            _transport.ConnectionStatusChanged += OnConnectionStatusChanged;\n            _transport.Received += OnDataReceived;\n            \n            Debug.Log(\"MinecraftNetworkClient initialized\");\n        }\n        \n        /// <summary>\n        /// 서버에 연결합니다.\n        /// </summary>\n        public async Task<bool> ConnectAsync()\n        {\n            try\n            {\n                Debug.Log($\"Connecting to Minecraft server at {serverAddress}:{serverPort}...\");\n                \n                var connectTask = _transport.ConnectAsync(serverAddress, serverPort);\n                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(connectionTimeout));\n                \n                var completedTask = await Task.WhenAny(connectTask, timeoutTask);\n                \n                if (completedTask == timeoutTask)\n                {\n                    ErrorOccurred?.Invoke(\"Connection timed out\");\n                    return false;\n                }\n                \n                await connectTask;\n                \n                Debug.Log(\"Successfully connected to Minecraft server\");\n                return true;\n            }\n            catch (Exception ex)\n            {\n                ErrorOccurred?.Invoke($\"Failed to connect: {ex.Message}\");\n                return false;\n            }\n        }\n        \n        /// <summary>\n        /// 로그인을 수행합니다.\n        /// </summary>\n        public void SendLogin(string username, string password)\n        {\n            var loginRequest = new LoginRequest\n            {\n                Username = username,\n                Password = password,\n                ClientVersion = Application.version\n            };\n            \n            SendMessage(loginRequest);\n            Debug.Log($\"Sent login request for {username}\");\n        }\n        \n        /// <summary>\n        /// 청크를 요청합니다.\n        /// </summary>\n        public void RequestChunk(int chunkX, int chunkZ)\n        {\n            var chunkKey = new Vector2Int(chunkX, chunkZ);\n            if (_loadedChunks.ContainsKey(chunkKey)) return;\n            \n            var request = new ChunkRequest\n            {\n                ChunkX = chunkX,\n                ChunkZ = chunkZ,\n                ViewDistance = renderDistance\n            };\n            \n            SendMessage(request);\n        }\n        \n        /// <summary>\n        /// 다중 청크를 요청합니다.\n        /// </summary>\n        public void RequestChunks(Vector2Int playerChunk)\n        {\n            var chunksToRequest = new List<Vector3Int>();\n            \n            for (int x = playerChunk.x - renderDistance; x <= playerChunk.x + renderDistance; x++)\n            {\n                for (int z = playerChunk.y - renderDistance; z <= playerChunk.y + renderDistance; z++)\n                {\n                    var chunkKey = new Vector2Int(x, z);\n                    if (!_loadedChunks.ContainsKey(chunkKey))\n                    {\n                        chunksToRequest.Add(new Vector3Int { X = x, Z = z });\n                    }\n                }\n            }\n            \n            if (chunksToRequest.Count > 0)\n            {\n                var request = new MultiChunkRequest\n                {\n                    ViewDistance = renderDistance\n                };\n                request.ChunkPositions.AddRange(chunksToRequest);\n                \n                SendMessage(request);\n                Debug.Log($\"Requested {chunksToRequest.Count} chunks around ({playerChunk.x}, {playerChunk.y})\");\n            }\n        }\n        \n        /// <summary>\n        /// 플레이어 이동을 전송합니다.\n        /// </summary>\n        public void SendPlayerMove(Vector3 position, Vector3 rotation, bool isOnGround = true, \n            bool isSneaking = false, bool isSprinting = false, bool isFlying = false)\n        {\n            var moveRequest = new PlayerMoveRequest\n            {\n                Position = new MinecraftProtocol.Vector3 { X = position.x, Y = position.y, Z = position.z },\n                Rotation = new MinecraftProtocol.Vector3 { X = rotation.x, Y = rotation.y, Z = rotation.z },\n                IsOnGround = isOnGround,\n                IsSneaking = isSneaking,\n                IsSprinting = isSprinting,\n                IsFlying = isFlying,\n                Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()\n            };\n            \n            SendMessage(moveRequest);\n        }\n        \n        /// <summary>\n        /// 블록 변경을 요청합니다.\n        /// </summary>\n        public void SendBlockChange(Vector3Int position, int newBlockId, int metadata = 0, \n            string blockEntityData = null, PlayerAction actionType = PlayerAction.PlaceBlock)\n        {\n            var request = new BlockChangeRequest\n            {\n                Position = new Vector3Int { X = position.x, Y = position.y, Z = position.z },\n                NewBlockId = newBlockId,\n                Metadata = metadata,\n                BlockEntityData = blockEntityData ?? \"\",\n                ActionType = actionType,\n                Sequence = UnityEngine.Random.Range(1000, 9999)\n            };\n            \n            SendMessage(request);\n            Debug.Log($\"Sent block change: {position} -> Block ID {newBlockId}\");\n        }\n        \n        /// <summary>\n        /// 플레이어 액션을 전송합니다 (블록 부수기, 아이템 사용 등).\n        /// </summary>\n        public void SendPlayerAction(PlayerAction action, Vector3Int targetPosition, int face = 0, \n            Vector3 cursorPosition = default, InventoryItem usedItem = null)\n        {\n            var request = new PlayerActionRequest\n            {\n                Action = action,\n                TargetPosition = new Vector3Int { X = targetPosition.x, Y = targetPosition.y, Z = targetPosition.z },\n                Face = face,\n                CursorPosition = new MinecraftProtocol.Vector3 \n                { \n                    X = cursorPosition.x, Y = cursorPosition.y, Z = cursorPosition.z \n                },\n                UsedItem = usedItem,\n                Sequence = UnityEngine.Random.Range(1000, 9999)\n            };\n            \n            SendMessage(request);\n        }\n        \n        /// <summary>\n        /// 인벤토리 업데이트를 전송합니다.\n        /// </summary>\n        public void SendInventoryUpdate(int slot, InventoryItem item, InventoryAction action, \n            int button = 0, InventoryItem cursorItem = null)\n        {\n            var request = new InventoryUpdateRequest\n            {\n                Slot = slot,\n                Item = item,\n                Action = action,\n                Button = button,\n                CursorItem = cursorItem\n            };\n            \n            SendMessage(request);\n        }\n        \n        /// <summary>\n        /// 채팅 메시지를 전송합니다.\n        /// </summary>\n        public void SendChatMessage(string message, ChatType type = ChatType.Global, string targetPlayer = \"\")\n        {\n            var request = new ChatRequest\n            {\n                Message = message,\n                Type = type,\n                TargetPlayer = targetPlayer\n            };\n            \n            SendMessage(request);\n        }\n        \n        /// <summary>\n        /// 명령어를 실행합니다.\n        /// </summary>\n        public void SendCommand(string command, params string[] arguments)\n        {\n            var request = new CommandRequest\n            {\n                Command = command\n            };\n            request.Arguments.AddRange(arguments);\n            \n            SendMessage(request);\n        }\n        \n        /// <summary>\n        /// 메시지를 전송 큐에 추가합니다.\n        /// </summary>\n        private void SendMessage(IMessage message)\n        {\n            if (!_isConnected)\n            {\n                Debug.LogWarning($\"Cannot send {message.GetType().Name}: not connected\");\n                return;\n            }\n            \n            _outgoingMessages.Enqueue(message);\n        }\n        \n        /// <summary>\n        /// 하트비트를 전송합니다.\n        /// </summary>\n        private void SendHeartbeat()\n        {\n            var ping = new PingRequest\n            {\n                ClientTimestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()\n            };\n            \n            SendMessage(ping);\n        }\n        \n        /// <summary>\n        /// 송신 메시지들을 처리합니다.\n        /// </summary>\n        private void ProcessOutgoingMessages()\n        {\n            while (_outgoingMessages.Count > 0 && _isConnected)\n            {\n                var message = _outgoingMessages.Dequeue();\n                try\n                {\n                    var data = SerializeMessage(message);\n                    _transport.Send(new ArraySegment<byte>(data));\n                }\n                catch (Exception ex)\n                {\n                    Debug.LogError($\"Failed to send message {message.GetType().Name}: {ex.Message}\");\n                }\n            }\n        }\n        \n        /// <summary>\n        /// 수신 메시지들을 처리합니다.\n        /// </summary>\n        private void ProcessIncomingMessages()\n        {\n            while (_incomingMessages.Count > 0)\n            {\n                var message = _incomingMessages.Dequeue();\n                try\n                {\n                    HandleIncomingMessage(message);\n                }\n                catch (Exception ex)\n                {\n                    Debug.LogError($\"Failed to handle message {message.GetType().Name}: {ex.Message}\");\n                }\n            }\n        }\n        \n        /// <summary>\n        /// 메시지를 직렬화합니다.\n        /// </summary>\n        private byte[] SerializeMessage(IMessage message)\n        {\n            using var stream = new System.IO.MemoryStream();\n            message.WriteTo(stream);\n            return stream.ToArray();\n        }\n        \n        /// <summary>\n        /// 네트워크 데이터를 수신했을 때 호출됩니다.\n        /// </summary>\n        private void OnDataReceived(ArraySegment<byte> data)\n        {\n            try\n            {\n                var message = DeserializeMessage(data);\n                if (message != null)\n                {\n                    _incomingMessages.Enqueue(message);\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"Failed to deserialize message: {ex.Message}\");\n            }\n        }\n        \n        /// <summary>\n        /// 메시지를 역직렬화합니다.\n        /// </summary>\n        private IMessage DeserializeMessage(ArraySegment<byte> data)\n        {\n            using var stream = new System.IO.MemoryStream(data.Array, data.Offset, data.Count);\n            \n            // TODO: 실제 구현에서는 메시지 타입 헤더를 읽어서 적절한 타입으로 역직렬화해야 합니다.\n            // 현재는 간단한 구현으로 여러 타입을 시도합니다.\n            \n            // 로그인 응답 시도\n            try\n            {\n                stream.Position = 0;\n                return LoginResponse.Parser.ParseFrom(stream);\n            }\n            catch { }\n            \n            // 청크 응답 시도\n            try\n            {\n                stream.Position = 0;\n                return ChunkResponse.Parser.ParseFrom(stream);\n            }\n            catch { }\n            \n            // 기타 메시지 타입들...\n            return null;\n        }\n        \n        /// <summary>\n        /// 수신한 메시지를 처리합니다.\n        /// </summary>\n        private void HandleIncomingMessage(IMessage message)\n        {\n            switch (message)\n            {\n                case LoginResponse loginResponse:\n                    HandleLoginResponse(loginResponse);\n                    break;\n                    \n                case ChunkResponse chunkResponse:\n                    HandleChunkResponse(chunkResponse);\n                    break;\n                    \n                case MultiChunkResponse multiChunkResponse:\n                    HandleMultiChunkResponse(multiChunkResponse);\n                    break;\n                    \n                case PlayerMoveResponse moveResponse:\n                    HandleMoveResponse(moveResponse);\n                    break;\n                    \n                case BlockChangeBroadcast blockBroadcast:\n                    HandleBlockChangeBroadcast(blockBroadcast);\n                    break;\n                    \n                case EntitySpawnBroadcast entitySpawn:\n                    HandleEntitySpawnBroadcast(entitySpawn);\n                    break;\n                    \n                case EntityDespawnBroadcast entityDespawn:\n                    HandleEntityDespawnBroadcast(entityDespawn);\n                    break;\n                    \n                case ChatMessage chatMessage:\n                    HandleChatMessage(chatMessage);\n                    break;\n                    \n                case PingResponse pingResponse:\n                    HandlePingResponse(pingResponse);\n                    break;\n                    \n                default:\n                    Debug.LogWarning($\"Unhandled message type: {message.GetType().Name}\");\n                    break;\n            }\n        }\n        \n        // 메시지 핸들러들\n        private void HandleLoginResponse(LoginResponse response)\n        {\n            if (response.Success)\n            {\n                _sessionToken = response.SessionToken;\n                _playerInfo = response.PlayerInfo;\n                _worldInfo = response.WorldInfo;\n                \n                PlayerInfoUpdated?.Invoke(_playerInfo);\n                \n                Debug.Log($\"Login successful: {response.Message}\");\n                \n                // 스폰 지점 주변 청크 요청\n                if (_worldInfo?.SpawnPoint != null)\n                {\n                    var spawnChunk = new Vector2Int(\n                        Mathf.FloorToInt((float)_worldInfo.SpawnPoint.Position.X / 16),\n                        Mathf.FloorToInt((float)_worldInfo.SpawnPoint.Position.Z / 16)\n                    );\n                    RequestChunks(spawnChunk);\n                }\n            }\n            else\n            {\n                ErrorOccurred?.Invoke($\"Login failed: {response.Message}\");\n            }\n        }\n        \n        private void HandleChunkResponse(ChunkResponse response)\n        {\n            if (response.Success && response.ChunkData != null)\n            {\n                var chunkKey = new Vector2Int(response.ChunkData.ChunkX, response.ChunkData.ChunkZ);\n                _loadedChunks[chunkKey] = response.ChunkData;\n                \n                ChunkLoaded?.Invoke(response.ChunkData);\n                Debug.Log($\"Loaded chunk ({response.ChunkData.ChunkX}, {response.ChunkData.ChunkZ})\");\n            }\n        }\n        \n        private void HandleMultiChunkResponse(MultiChunkResponse response)\n        {\n            foreach (var chunk in response.Chunks)\n            {\n                var chunkKey = new Vector2Int(chunk.ChunkX, chunk.ChunkZ);\n                _loadedChunks[chunkKey] = chunk;\n                ChunkLoaded?.Invoke(chunk);\n            }\n            \n            Debug.Log($\"Loaded {response.SentChunks} chunks (total available: {response.TotalChunks})\");\n        }\n        \n        private void HandleMoveResponse(PlayerMoveResponse response)\n        {\n            if (response.Success && response.CorrectedPosition != null)\n            {\n                // 서버에서 수정된 위치로 플레이어 위치 보정\n                var correctedPos = response.CorrectedPosition;\n                var worldPos = new Vector3((float)correctedPos.X, (float)correctedPos.Y, (float)correctedPos.Z);\n                \n                // 플레이어 위치 업데이트 이벤트 발생\n                if (_playerInfo != null)\n                {\n                    _playerInfo.Position = correctedPos;\n                    PlayerInfoUpdated?.Invoke(_playerInfo);\n                }\n            }\n            else\n            {\n                Debug.LogWarning($\"Move rejected: {response.ErrorMessage}\");\n            }\n        }\n        \n        private void HandleBlockChangeBroadcast(BlockChangeBroadcast broadcast)\n        {\n            var pos = broadcast.Position;\n            var unityPos = new Vector3Int(pos.X, pos.Y, pos.Z);\n            \n            BlockChanged?.Invoke(unityPos, broadcast.OldBlockId, broadcast.NewBlockId);\n            Debug.Log($\"Block changed at {unityPos}: {broadcast.OldBlockId} -> {broadcast.NewBlockId} by {broadcast.PlayerName}\");\n        }\n        \n        private void HandleEntitySpawnBroadcast(EntitySpawnBroadcast broadcast)\n        {\n            var entity = broadcast.Entity;\n            _entities[entity.EntityId] = entity;\n            \n            EntitySpawned?.Invoke(entity);\n            Debug.Log($\"Entity spawned: {entity.EntityType} at ({entity.Position.X}, {entity.Position.Y}, {entity.Position.Z})\");\n        }\n        \n        private void HandleEntityDespawnBroadcast(EntityDespawnBroadcast broadcast)\n        {\n            _entities.Remove(broadcast.EntityId);\n            \n            EntityDespawned?.Invoke(broadcast.EntityId);\n            Debug.Log($\"Entity despawned: {broadcast.EntityId} (reason: {broadcast.Reason})\");\n        }\n        \n        private void HandleChatMessage(ChatMessage message)\n        {\n            ChatMessageReceived?.Invoke(message);\n            Debug.Log($\"[{message.Type}] {message.SenderName}: {message.Message}\");\n        }\n        \n        private void HandlePingResponse(PingResponse response)\n        {\n            var latency = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - response.ClientTimestamp;\n            // Debug.Log($\"Ping: {latency}ms\");\n        }\n        \n        private void OnConnectionStatusChanged(bool isConnected)\n        {\n            _isConnected = isConnected;\n            ConnectionStatusChanged?.Invoke(isConnected);\n            \n            if (!isConnected)\n            {\n                // 연결이 끊어지면 데이터 초기화\n                _loadedChunks.Clear();\n                _entities.Clear();\n                _sessionToken = null;\n                _playerInfo = null;\n                _worldInfo = null;\n            }\n        }\n        \n        /// <summary>\n        /// 특정 청크가 로드되었는지 확인합니다.\n        /// </summary>\n        public bool IsChunkLoaded(int chunkX, int chunkZ)\n        {\n            return _loadedChunks.ContainsKey(new Vector2Int(chunkX, chunkZ));\n        }\n        \n        /// <summary>\n        /// 로드된 청크를 가져옵니다.\n        /// </summary>\n        public ChunkInfo GetChunk(int chunkX, int chunkZ)\n        {\n            _loadedChunks.TryGetValue(new Vector2Int(chunkX, chunkZ), out var chunk);\n            return chunk;\n        }\n        \n        /// <summary>\n        /// 특정 위치의 엔티티를 가져옵니다.\n        /// </summary>\n        public EntityInfo GetEntity(string entityId)\n        {\n            _entities.TryGetValue(entityId, out var entity);\n            return entity;\n        }\n        \n        /// <summary>\n        /// 모든 로드된 엔티티를 가져옵니다.\n        /// </summary>\n        public IReadOnlyDictionary<string, EntityInfo> GetAllEntities()\n        {\n            return _entities;\n        }\n        \n        private void OnDestroy()\n        {\n            if (_transport != null)\n            {\n                _transport.ConnectionStatusChanged -= OnConnectionStatusChanged;\n                _transport.Received -= OnDataReceived;\n                \n                if (_transport is IDisposable disposable)\n                {\n                    disposable.Dispose();\n                }\n            }\n        }\n    }\n}