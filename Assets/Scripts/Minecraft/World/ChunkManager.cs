using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing MinecraftProtocol;\n\nnamespace Minecraft.World\n{\n    /// <summary>\n    /// 마인크래프트 월드의 청크를 관리하는 시스템\n    /// 청크 로딩, 언로딩, 렌더링, 블록 관리 등을 담당합니다.\n    /// </summary>\n    public class ChunkManager : MonoBehaviour\n    {\n        [Header(\"Chunk Settings\")]\n        [SerializeField] private int chunkSize = 16;          // 청크 크기 (16x16)\n        [SerializeField] private int worldHeight = 256;       // 월드 높이\n        [SerializeField] private int renderDistance = 8;      // 렌더 거리\n        [SerializeField] private Material blockMaterial;      // 블록 머티리얼\n        [SerializeField] private GameObject chunkPrefab;      // 청크 프리팹\n        \n        [Header(\"Performance Settings\")]\n        [SerializeField] private int chunksPerFrame = 2;      // 프레임당 처리할 청크 수\n        [SerializeField] private float chunkUpdateInterval = 0.1f; // 청크 업데이트 간격\n        \n        // 청크 데이터 및 게임오브젝트\n        private Dictionary<Vector2Int, ChunkInfo> _chunkData = new();\n        private Dictionary<Vector2Int, GameObject> _chunkObjects = new();\n        private Dictionary<Vector2Int, ChunkRenderer> _chunkRenderers = new();\n        \n        // 청크 로딩 관리\n        private Vector2Int _playerChunkPos;\n        private Queue<Vector2Int> _chunksToLoad = new();\n        private Queue<Vector2Int> _chunksToUnload = new();\n        private Queue<Vector2Int> _chunksToUpdate = new();\n        \n        // 블록 타입 정의\n        private Dictionary<int, BlockType> _blockTypes = new();\n        \n        // 이벤트\n        public event Action<Vector2Int> ChunkLoaded;\n        public event Action<Vector2Int> ChunkUnloaded;\n        public event Action<Vector3Int, int, int> BlockChanged;\n        \n        // 프로퍼티\n        public int LoadedChunkCount => _chunkData.Count;\n        public Vector2Int PlayerChunkPosition => _playerChunkPos;\n        \n        private void Start()\n        {\n            InitializeBlockTypes();\n            \n            // 주기적 업데이트 시작\n            InvokeRepeating(nameof(ProcessChunkUpdates), 0f, chunkUpdateInterval);\n        }\n        \n        private void Update()\n        {\n            UpdatePlayerChunkPosition();\n            ProcessChunkQueues();\n        }\n        \n        /// <summary>\n        /// 블록 타입을 초기화합니다.\n        /// </summary>\n        private void InitializeBlockTypes()\n        {\n            // 기본 블록 타입들 정의\n            _blockTypes[0] = new BlockType(0, \"Air\", false, false);\n            _blockTypes[1] = new BlockType(1, \"Stone\", true, true);\n            _blockTypes[2] = new BlockType(2, \"Grass\", true, true);\n            _blockTypes[3] = new BlockType(3, \"Dirt\", true, true);\n            _blockTypes[4] = new BlockType(4, \"Cobblestone\", true, true);\n            _blockTypes[5] = new BlockType(5, \"Wood\", true, true);\n            _blockTypes[6] = new BlockType(6, \"Leaves\", true, false);\n            _blockTypes[7] = new BlockType(7, \"Sand\", true, true);\n            _blockTypes[8] = new BlockType(8, \"Water\", false, false);\n            _blockTypes[9] = new BlockType(9, \"Lava\", false, false);\n            \n            Debug.Log($\"Initialized {_blockTypes.Count} block types\");\n        }\n        \n        /// <summary>\n        /// 플레이어 청크 위치를 업데이트합니다.\n        /// </summary>\n        private void UpdatePlayerChunkPosition()\n        {\n            var playerPos = transform.position;\n            var newChunkPos = new Vector2Int(\n                Mathf.FloorToInt(playerPos.x / chunkSize),\n                Mathf.FloorToInt(playerPos.z / chunkSize)\n            );\n            \n            if (newChunkPos != _playerChunkPos)\n            {\n                _playerChunkPos = newChunkPos;\n                UpdateChunkLoadingArea();\n            }\n        }\n        \n        /// <summary>\n        /// 청크 로딩 영역을 업데이트합니다.\n        /// </summary>\n        private void UpdateChunkLoadingArea()\n        {\n            var chunksInRange = new HashSet<Vector2Int>();\n            \n            // 렌더 거리 내의 청크들을 계산\n            for (int x = _playerChunkPos.x - renderDistance; x <= _playerChunkPos.x + renderDistance; x++)\n            {\n                for (int z = _playerChunkPos.y - renderDistance; z <= _playerChunkPos.y + renderDistance; z++)\n                {\n                    var chunkPos = new Vector2Int(x, z);\n                    var distance = Vector2Int.Distance(_playerChunkPos, chunkPos);\n                    \n                    if (distance <= renderDistance)\n                    {\n                        chunksInRange.Add(chunkPos);\n                        \n                        // 로드되지 않은 청크는 로딩 큐에 추가\n                        if (!_chunkData.ContainsKey(chunkPos) && !_chunksToLoad.Contains(chunkPos))\n                        {\n                            _chunksToLoad.Enqueue(chunkPos);\n                        }\n                    }\n                }\n            }\n            \n            // 범위를 벗어난 청크들은 언로드 큐에 추가\n            var chunksToUnload = new List<Vector2Int>();\n            foreach (var loadedChunk in _chunkData.Keys)\n            {\n                if (!chunksInRange.Contains(loadedChunk))\n                {\n                    chunksToUnload.Add(loadedChunk);\n                }\n            }\n            \n            foreach (var chunkPos in chunksToUnload)\n            {\n                if (!_chunksToUnload.Contains(chunkPos))\n                {\n                    _chunksToUnload.Enqueue(chunkPos);\n                }\n            }\n        }\n        \n        /// <summary>\n        /// 청크 큐들을 처리합니다.\n        /// </summary>\n        private void ProcessChunkQueues()\n        {\n            int processedCount = 0;\n            \n            // 언로드 처리\n            while (_chunksToUnload.Count > 0 && processedCount < chunksPerFrame)\n            {\n                var chunkPos = _chunksToUnload.Dequeue();\n                UnloadChunk(chunkPos);\n                processedCount++;\n            }\n            \n            // 로드 처리\n            while (_chunksToLoad.Count > 0 && processedCount < chunksPerFrame)\n            {\n                var chunkPos = _chunksToLoad.Dequeue();\n                // 실제 로딩은 네트워크에서 받은 데이터로 처리\n                RequestChunkFromServer(chunkPos);\n                processedCount++;\n            }\n        }\n        \n        /// <summary>\n        /// 주기적으로 청크 업데이트를 처리합니다.\n        /// </summary>\n        private void ProcessChunkUpdates()\n        {\n            int updateCount = 0;\n            while (_chunksToUpdate.Count > 0 && updateCount < chunksPerFrame)\n            {\n                var chunkPos = _chunksToUpdate.Dequeue();\n                if (_chunkRenderers.TryGetValue(chunkPos, out var renderer))\n                {\n                    renderer.UpdateMesh();\n                }\n                updateCount++;\n            }\n        }\n        \n        /// <summary>\n        /// 서버에 청크 데이터를 요청합니다.\n        /// </summary>\n        private void RequestChunkFromServer(Vector2Int chunkPos)\n        {\n            var networkClient = FindObjectOfType<Core.MinecraftNetworkClient>();\n            if (networkClient != null)\n            {\n                networkClient.RequestChunk(chunkPos.x, chunkPos.y);\n            }\n        }\n        \n        /// <summary>\n        /// 청크를 로드합니다.\n        /// </summary>\n        public void LoadChunk(ChunkInfo chunkInfo)\n        {\n            var chunkPos = new Vector2Int(chunkInfo.ChunkX, chunkInfo.ChunkZ);\n            \n            if (_chunkData.ContainsKey(chunkPos))\n            {\n                // 이미 로드된 청크는 업데이트\n                UpdateChunk(chunkInfo);\n                return;\n            }\n            \n            // 새 청크 데이터 저장\n            _chunkData[chunkPos] = chunkInfo;\n            \n            // 청크 게임오브젝트 생성\n            var chunkObj = CreateChunkObject(chunkPos);\n            _chunkObjects[chunkPos] = chunkObj;\n            \n            // 청크 렌더러 생성\n            var renderer = chunkObj.GetComponent<ChunkRenderer>();\n            if (renderer == null)\n            {\n                renderer = chunkObj.AddComponent<ChunkRenderer>();\n            }\n            \n            renderer.Initialize(chunkInfo, _blockTypes, blockMaterial);\n            _chunkRenderers[chunkPos] = renderer;\n            \n            // 엔티티 생성\n            foreach (var entity in chunkInfo.Entities)\n            {\n                CreateEntity(entity);\n            }\n            \n            ChunkLoaded?.Invoke(chunkPos);\n            Debug.Log($\"Loaded chunk ({chunkPos.x}, {chunkPos.y})\");\n        }\n        \n        /// <summary>\n        /// 청크를 업데이트합니다.\n        /// </summary>\n        public void UpdateChunk(ChunkInfo chunkInfo)\n        {\n            var chunkPos = new Vector2Int(chunkInfo.ChunkX, chunkInfo.ChunkZ);\n            \n            if (!_chunkData.ContainsKey(chunkPos)) return;\n            \n            _chunkData[chunkPos] = chunkInfo;\n            \n            if (_chunkRenderers.TryGetValue(chunkPos, out var renderer))\n            {\n                renderer.UpdateData(chunkInfo);\n                _chunksToUpdate.Enqueue(chunkPos);\n            }\n        }\n        \n        /// <summary>\n        /// 청크를 언로드합니다.\n        /// </summary>\n        public void UnloadChunk(Vector2Int chunkPos)\n        {\n            if (!_chunkData.ContainsKey(chunkPos)) return;\n            \n            // 청크 데이터 제거\n            _chunkData.Remove(chunkPos);\n            \n            // 게임오브젝트 제거\n            if (_chunkObjects.TryGetValue(chunkPos, out var chunkObj))\n            {\n                DestroyImmediate(chunkObj);\n                _chunkObjects.Remove(chunkPos);\n            }\n            \n            // 렌더러 제거\n            _chunkRenderers.Remove(chunkPos);\n            \n            ChunkUnloaded?.Invoke(chunkPos);\n            Debug.Log($\"Unloaded chunk ({chunkPos.x}, {chunkPos.y})\");\n        }\n        \n        /// <summary>\n        /// 청크 게임오브젝트를 생성합니다.\n        /// </summary>\n        private GameObject CreateChunkObject(Vector2Int chunkPos)\n        {\n            var chunkObj = chunkPrefab != null ? Instantiate(chunkPrefab) : new GameObject($\"Chunk_{chunkPos.x}_{chunkPos.y}\");\n            \n            // 청크 위치 설정\n            var worldPos = new Vector3(chunkPos.x * chunkSize, 0, chunkPos.y * chunkSize);\n            chunkObj.transform.position = worldPos;\n            chunkObj.transform.parent = transform;\n            \n            // 필요한 컴포넌트 추가\n            if (chunkObj.GetComponent<MeshFilter>() == null)\n                chunkObj.AddComponent<MeshFilter>();\n            if (chunkObj.GetComponent<MeshRenderer>() == null)\n            {\n                var meshRenderer = chunkObj.AddComponent<MeshRenderer>();\n                meshRenderer.material = blockMaterial;\n            }\n            if (chunkObj.GetComponent<MeshCollider>() == null)\n                chunkObj.AddComponent<MeshCollider>();\n            \n            return chunkObj;\n        }\n        \n        /// <summary>\n        /// 엔티티를 생성합니다.\n        /// </summary>\n        private void CreateEntity(EntityInfo entityInfo)\n        {\n            // TODO: 엔티티 타입에 따른 게임오브젝트 생성\n            var entityObj = new GameObject($\"Entity_{entityInfo.EntityId}\");\n            var pos = entityInfo.Position;\n            entityObj.transform.position = new Vector3((float)pos.X, (float)pos.Y, (float)pos.Z);\n            entityObj.transform.parent = transform;\n            \n            // 엔티티 컴포넌트 추가\n            var entityComponent = entityObj.AddComponent<EntityController>();\n            entityComponent.Initialize(entityInfo);\n        }\n        \n        /// <summary>\n        /// 블록을 변경합니다.\n        /// </summary>\n        public void ChangeBlock(Vector3Int blockPos, int oldBlockId, int newBlockId)\n        {\n            var chunkPos = new Vector2Int(\n                Mathf.FloorToInt(blockPos.x / (float)chunkSize),\n                Mathf.FloorToInt(blockPos.z / (float)chunkSize)\n            );\n            \n            if (!_chunkData.TryGetValue(chunkPos, out var chunkData)) return;\n            \n            // 청크 내 로컬 블록 위치 계산\n            var localBlockPos = new Vector3Int(\n                blockPos.x - (chunkPos.x * chunkSize),\n                blockPos.y,\n                blockPos.z - (chunkPos.y * chunkSize)\n            );\n            \n            // 블록 데이터 업데이트\n            UpdateBlockInChunk(chunkData, localBlockPos, newBlockId);\n            \n            // 메시 업데이트 큐에 추가\n            if (!_chunksToUpdate.Contains(chunkPos))\n            {\n                _chunksToUpdate.Enqueue(chunkPos);\n            }\n            \n            BlockChanged?.Invoke(blockPos, oldBlockId, newBlockId);\n        }\n        \n        /// <summary>\n        /// 청크 내 블록 데이터를 업데이트합니다.\n        /// </summary>\n        private void UpdateBlockInChunk(ChunkInfo chunkData, Vector3Int localPos, int newBlockId)\n        {\n            // 블록 정보 검색 및 업데이트\n            foreach (var block in chunkData.Blocks)\n            {\n                if (block.Position.X == localPos.x && \n                    block.Position.Y == localPos.y && \n                    block.Position.Z == localPos.z)\n                {\n                    // 기존 블록 정보를 업데이트\n                    var updatedBlock = new BlockInfo\n                    {\n                        BlockId = newBlockId,\n                        Position = block.Position,\n                        Metadata = block.Metadata,\n                        BlockEntityData = block.BlockEntityData,\n                        LastUpdate = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()\n                    };\n                    \n                    // TODO: 실제로는 protobuf의 repeated field를 수정해야 함\n                    break;\n                }\n            }\n        }\n        \n        /// <summary>\n        /// 특정 위치의 블록 ID를 가져옵니다.\n        /// </summary>\n        public int GetBlockAt(Vector3Int worldPos)\n        {\n            var chunkPos = new Vector2Int(\n                Mathf.FloorToInt(worldPos.x / (float)chunkSize),\n                Mathf.FloorToInt(worldPos.z / (float)chunkSize)\n            );\n            \n            if (!_chunkData.TryGetValue(chunkPos, out var chunkData))\n                return 0; // Air\n            \n            var localPos = new Vector3Int(\n                worldPos.x - (chunkPos.x * chunkSize),\n                worldPos.y,\n                worldPos.z - (chunkPos.y * chunkSize)\n            );\n            \n            foreach (var block in chunkData.Blocks)\n            {\n                if (block.Position.X == localPos.x && \n                    block.Position.Y == localPos.y && \n                    block.Position.Z == localPos.z)\n                {\n                    return block.BlockId;\n                }\n            }\n            \n            return 0; // Air (기본값)\n        }\n        \n        /// <summary>\n        /// 블록 타입 정보를 가져옵니다.\n        /// </summary>\n        public BlockType GetBlockType(int blockId)\n        {\n            _blockTypes.TryGetValue(blockId, out var blockType);\n            return blockType ?? _blockTypes[0]; // Air가 기본값\n        }\n        \n        /// <summary>\n        /// 청크가 로드되었는지 확인합니다.\n        /// </summary>\n        public bool IsChunkLoaded(Vector2Int chunkPos)\n        {\n            return _chunkData.ContainsKey(chunkPos);\n        }\n        \n        /// <summary>\n        /// 로드된 모든 청크 위치를 가져옵니다.\n        /// </summary>\n        public IEnumerable<Vector2Int> GetLoadedChunks()\n        {\n            return _chunkData.Keys;\n        }\n        \n        private void OnDrawGizmosSelected()\n        {\n            // 렌더 거리 시각화\n            Gizmos.color = Color.yellow;\n            var centerPos = new Vector3(_playerChunkPos.x * chunkSize, 0, _playerChunkPos.y * chunkSize);\n            Gizmos.DrawWireCube(centerPos, new Vector3(renderDistance * chunkSize * 2, 10, renderDistance * chunkSize * 2));\n            \n            // 로드된 청크들 시각화\n            Gizmos.color = Color.green;\n            foreach (var chunkPos in _chunkData.Keys)\n            {\n                var worldPos = new Vector3(chunkPos.x * chunkSize, 5, chunkPos.y * chunkSize);\n                Gizmos.DrawWireCube(worldPos, new Vector3(chunkSize, 10, chunkSize));\n            }\n        }\n    }\n    \n    /// <summary>\n    /// 블록 타입 정의\n    /// </summary>\n    [System.Serializable]\n    public class BlockType\n    {\n        public int Id { get; }\n        public string Name { get; }\n        public bool IsSolid { get; }\n        public bool IsOpaque { get; }\n        public float Hardness { get; set; } = 1f;\n        public string TextureName { get; set; }\n        \n        public BlockType(int id, string name, bool isSolid, bool isOpaque)\n        {\n            Id = id;\n            Name = name;\n            IsSolid = isSolid;\n            IsOpaque = isOpaque;\n        }\n    }\n}